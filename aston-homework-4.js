// 1) Какие бывают алгоритмы сортировок ?
// а) Сортировка пузырьком (Bubble sort)
// // Суть алгоритма заключается в последовательном сравнении значений соседних элементов массива. Если следующий элемент меньше текущего, то мы их меняем местами. Повторять это действие нужно до тех пор, пока элементы массива не займут свое порядковое место. Если дошли до конца массива, а данные в нем еще не рассортированы, нужно начать проходить сначала.
// б) Сортировка перемешиванием (Cocktail sort)
// Алгоритм представляет собой улучшенную версию сортировки пузырьком, который решает проблему последних элементов. К примеру, если в конце массива находится самый маленький элемент, то на каждой итерации он будет сдвигаться только на одну позицию.
// Для решения этой проблемы сортировка перемешиванием проходится по массиву два раза, меняя направление. В первом случае выполнение алгоритма идет с начала массива, сравнивая попарно соседние элементы. Местами они меняются в том случае, если элемент слева больше элемента справа. Если дошли до конца, то меняем направление и идем к началу. В этом случае меньшие элементы перемещаются влево. Алгоритм выполняется до тех пор, пока все элементы не займут свои места.
// в)Сортировка вставками (Insertion sort)
// Пошагово сортировка вставками выглядит так:
// Первый элемент считается отсортированным, а весь массив делится на две части. В первую часть входит первый элемент, а все остальное — неотсортированная часть.
// Берется первый элемент из неотсортированной части.
// Выбранный элемент помещается в правильное место отсортированной части, а остальные элементы в ней сдвигаются.
// Последние два шага повторяются по кругу: взяли элемент, нашли ему место и сделали это еще раз. В итоге в отсортированную часть массива должны войти все элементы.
// г)Сортировка выбором (Selection sort)
// Пошагово сортировка выбором выглядит следующим образом:

// Из неотсортированной части выбирается элемент с минимальным значением.
// Этот элемент обменивается местами с первым элементом в массиве.
// Поиск в неотсортированной части начинается снова, но уже отсортированные элементы не принимают в этом участие.
// Шаги выполняются по кругу до тех пор, пока все элементы массива не будут стоять на своих местах. Если надо отсортировать данные в обратном порядке, то следует искать максимальные элементы вместо минимальных.
// д)Быстрая сортировка (Quicksort)
// В начале выполнения быстрой сортировки необходимо выбрать опорный элемент. Чаще всего это один из крайних элементов, но можно сделать выбор случайным образом. Значение самого элемента не повлияет на скорость работы. После этого массив делится на две части: элементы меньше «опоры» перемещаются влево, а больше — вправо. Далее рекурсивно выполняем деление и сортировку для каждой части до тех пор, пока части не достигнут минимального размера.
// 2) Прочитать про "Операторы и выражения, циклы в JS"
// Операторы и выражения в JavaScript используются для выполнения различных операций над данными. Вот несколько ключевых моментов:

// Арифметические операторы: Позволяют выполнять математические операции, такие как сложение (+), вычитание (-), умножение (*), деление (/), остаток от деления (%).
// Операторы присваивания: Используются для присваивания значения переменной. Например, = присваивает значение, += прибавляет к текущему значению переменной и т. д.
// Сравнительные операторы: Сравнивают два значения и возвращают результат в виде логического значения (true или false). Например, ==, === (строгое равенство), !=, !==, >, <, >=, <=.
// Логические операторы: Используются для комбинирования или инвертирования логических выражений. Например, && (логическое И), || (логическое ИЛИ), ! (логическое НЕ).
// Условный (тернарный) оператор: Представляет собой краткую форму записи условного выражения. Например, condition ? expression1 : expression2.
// Циклы используются для выполнения повторяющихся операций:

// Цикл for: Используется для выполнения определенного блока кода заданное количество раз. Синтаксис: for (начальное_значение; условие_продолжения; шаг) { ... }.
// Цикл while: Выполняет блок кода, пока условие истинно. Синтаксис: while (условие) { ... }.
// Цикл do...while: Выполняет блок кода, а затем проверяет условие. Если условие истинно, цикл повторяется. Синтаксис: do { ... } while (условие).
// Цикл for...of: Перебирает элементы массива или итерируемого объекта. Синтаксис: for (const element of array) { ... }.
// Цикл for...in: Перебирает перечислимые свойства объекта. Синтаксис: for (const key in object) { ... }.
// 3) Создать объект Person несколькими способами, после создать объект Person2, чтобы в нём были доступны методы объекта Person. Добавить метод logInfo чтоб он был доступен всем объектам.
// const Person = { name: "John", age: 30 };
// const Person2 = Object.create(Person);
// Person2.name = "Alice";
// Person2.age = "28";
// Person.logInfo = function () {
//   console.log(`Hello ${this.name}, your age is ${this.age}`);
// };
// class Person {
//   constructor(name, age) {
//     this.name = name,
//       this.age = age,
//       this.logInfo = function () {
//         console.log(`Hello ${this.name}, your age is ${this.age}`);
//       };
//   }
// }
// const person = new Person("John", 30);
// const person2 = new Person("Alice", 28);
// 4) Создать класс PersonThree c get и set для поля name и конструктором, сделать класс наследник от класса Person.
class Person {
  constructor(name) {
    this.name = name;
  }
  get name() {
    return this.name;
  }
  set name(newName) {
    this.name = newName;
  }
}
class PersonThree extends Person {
  constructor(name, age) {
    super(name);
    this.age = age;
  }
}
// 5) Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total:
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const total = 13;
//result = [4, 9]

const firstSum = (arr, total) => {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] + arr[j] === total) {
        return [arr[i], arr[j]];
      }
    }
  }
  return [];
};

console.log(firstSum(arr, total));
// 2) Какая сложность у вашего алгоритма ? O(n^2)
